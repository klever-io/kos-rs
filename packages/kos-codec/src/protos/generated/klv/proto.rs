// This file is @generated by prost-build.
/// TXContract available
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferContract {
    #[prost(bytes = "vec", tag = "1")]
    pub to_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub amount: i64,
    #[prost(int64, tag = "4")]
    pub kda_royalties: i64,
}
/// CreateAssetContract holds the data for a Klever digital asset
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAssetContract {
    #[prost(enumeration = "create_asset_contract::EnumAssetType", tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub name: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub ticker: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub owner_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub logo: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "6")]
    pub ur_is: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(uint32, tag = "7")]
    pub precision: u32,
    #[prost(int64, tag = "8")]
    pub initial_supply: i64,
    #[prost(int64, tag = "9")]
    pub max_supply: i64,
    #[prost(message, optional, tag = "10")]
    pub royalties: ::core::option::Option<RoyaltiesInfo>,
    #[prost(message, optional, tag = "11")]
    pub properties: ::core::option::Option<PropertiesInfo>,
    #[prost(message, optional, tag = "12")]
    pub attributes: ::core::option::Option<AttributesInfo>,
    #[prost(message, optional, tag = "13")]
    pub staking: ::core::option::Option<StakingInfo>,
    #[prost(message, repeated, tag = "14")]
    pub roles: ::prost::alloc::vec::Vec<RolesInfo>,
}
/// Nested message and enum types in `CreateAssetContract`.
pub mod create_asset_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumAssetType {
        Fungible = 0,
        NonFungible = 1,
    }
    impl EnumAssetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Fungible => "Fungible",
                Self::NonFungible => "NonFungible",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Fungible" => Some(Self::Fungible),
                "NonFungible" => Some(Self::NonFungible),
                _ => None,
            }
        }
    }
}
/// PropertiesInfo hold the properties structure for the KDA asset
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PropertiesInfo {
    #[prost(bool, tag = "1")]
    pub can_freeze: bool,
    #[prost(bool, tag = "2")]
    pub can_wipe: bool,
    #[prost(bool, tag = "3")]
    pub can_pause: bool,
    #[prost(bool, tag = "4")]
    pub can_mint: bool,
    #[prost(bool, tag = "5")]
    pub can_burn: bool,
    #[prost(bool, tag = "6")]
    pub can_change_owner: bool,
    #[prost(bool, tag = "7")]
    pub can_add_roles: bool,
}
/// AttributesInfo hold the attributes structure for the KDA asset
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttributesInfo {
    #[prost(bool, tag = "1")]
    pub is_paused: bool,
    #[prost(bool, tag = "2")]
    pub is_nft_mint_stopped: bool,
    #[prost(bool, tag = "3")]
    pub is_royalties_change_stopped: bool,
    #[prost(bool, tag = "4")]
    pub is_nft_metadata_change_stopped: bool,
}
/// StakingInfo hold the staking structure for the KDA asset
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StakingInfo {
    #[prost(enumeration = "staking_info::InterestType", tag = "1")]
    pub r#type: i32,
    #[prost(uint32, tag = "2")]
    pub apr: u32,
    #[prost(uint32, tag = "3")]
    pub min_epochs_to_claim: u32,
    #[prost(uint32, tag = "4")]
    pub min_epochs_to_unstake: u32,
    #[prost(uint32, tag = "5")]
    pub min_epochs_to_withdraw: u32,
}
/// Nested message and enum types in `StakingInfo`.
pub mod staking_info {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InterestType {
        Apri = 0,
        Fpri = 1,
    }
    impl InterestType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Apri => "APRI",
                Self::Fpri => "FPRI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "APRI" => Some(Self::Apri),
                "FPRI" => Some(Self::Fpri),
                _ => None,
            }
        }
    }
}
/// RolesInfo holds the roles for a given asset and the given address
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolesInfo {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub has_role_mint: bool,
    #[prost(bool, tag = "3")]
    pub has_role_set_ito_prices: bool,
    #[prost(bool, tag = "4")]
    pub has_role_deposit: bool,
}
/// RoyaltiesInfo holds the royalties for a given asset
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoyaltiesInfo {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub transfer_percentage: ::prost::alloc::vec::Vec<RoyaltyInfo>,
    #[prost(int64, tag = "3")]
    pub transfer_fixed: i64,
    #[prost(uint32, tag = "4")]
    pub market_percentage: u32,
    #[prost(int64, tag = "5")]
    pub market_fixed: i64,
    #[prost(btree_map = "string, message", tag = "6")]
    pub split_royalties: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        RoyaltySplitInfo,
    >,
    #[prost(int64, tag = "7")]
    pub ito_fixed: i64,
    #[prost(uint32, tag = "8")]
    pub ito_percentage: u32,
}
/// RoyaltySplitInfo holds the royalty split
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoyaltySplitInfo {
    #[prost(uint32, tag = "1")]
    pub percent_transfer_percentage: u32,
    #[prost(uint32, tag = "2")]
    pub percent_transfer_fixed: u32,
    #[prost(uint32, tag = "3")]
    pub percent_market_percentage: u32,
    #[prost(uint32, tag = "4")]
    pub percent_market_fixed: u32,
    #[prost(uint32, tag = "5")]
    pub percent_ito_percentage: u32,
    #[prost(uint32, tag = "6")]
    pub percent_ito_fixed: u32,
}
/// RoyaltyInfo holds the royalty threshold
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RoyaltyInfo {
    #[prost(int64, tag = "1")]
    pub amount: i64,
    #[prost(uint32, tag = "2")]
    pub percentage: u32,
}
/// KDAPoolInfo holds the KDA Fee pool info
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KdaPoolInfo {
    #[prost(bool, tag = "1")]
    pub active: bool,
    #[prost(bytes = "vec", tag = "2")]
    pub admin_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub f_ratio_kda: i64,
    #[prost(int64, tag = "4")]
    pub f_ratio_klv: i64,
}
/// AssetTriggerContract triggers assets functions
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetTriggerContract {
    #[prost(enumeration = "asset_trigger_contract::EnumTriggerType", tag = "1")]
    pub trigger_type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub to_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "4")]
    pub amount: i64,
    #[prost(bytes = "vec", tag = "5")]
    pub mime: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "6")]
    pub logo: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "7")]
    pub ur_is: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "8")]
    pub role: ::core::option::Option<RolesInfo>,
    #[prost(message, optional, tag = "9")]
    pub staking: ::core::option::Option<StakingInfo>,
    #[prost(message, optional, tag = "10")]
    pub royalties: ::core::option::Option<RoyaltiesInfo>,
    #[prost(message, optional, tag = "11")]
    pub kda_pool: ::core::option::Option<KdaPoolInfo>,
}
/// Nested message and enum types in `AssetTriggerContract`.
pub mod asset_trigger_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumTriggerType {
        Mint = 0,
        Burn = 1,
        Wipe = 2,
        Pause = 3,
        Resume = 4,
        ChangeOwner = 5,
        AddRole = 6,
        RemoveRole = 7,
        UpdateMetadata = 8,
        StopNftMint = 9,
        UpdateLogo = 10,
        UpdateUrIs = 11,
        ChangeRoyaltiesReceiver = 12,
        UpdateStaking = 13,
        UpdateRoyalties = 14,
        UpdateKdaFeePool = 15,
        StopRoyaltiesChange = 16,
        StopNftMetadataChange = 17,
    }
    impl EnumTriggerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Mint => "Mint",
                Self::Burn => "Burn",
                Self::Wipe => "Wipe",
                Self::Pause => "Pause",
                Self::Resume => "Resume",
                Self::ChangeOwner => "ChangeOwner",
                Self::AddRole => "AddRole",
                Self::RemoveRole => "RemoveRole",
                Self::UpdateMetadata => "UpdateMetadata",
                Self::StopNftMint => "StopNFTMint",
                Self::UpdateLogo => "UpdateLogo",
                Self::UpdateUrIs => "UpdateURIs",
                Self::ChangeRoyaltiesReceiver => "ChangeRoyaltiesReceiver",
                Self::UpdateStaking => "UpdateStaking",
                Self::UpdateRoyalties => "UpdateRoyalties",
                Self::UpdateKdaFeePool => "UpdateKDAFeePool",
                Self::StopRoyaltiesChange => "StopRoyaltiesChange",
                Self::StopNftMetadataChange => "StopNFTMetadataChange",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Mint" => Some(Self::Mint),
                "Burn" => Some(Self::Burn),
                "Wipe" => Some(Self::Wipe),
                "Pause" => Some(Self::Pause),
                "Resume" => Some(Self::Resume),
                "ChangeOwner" => Some(Self::ChangeOwner),
                "AddRole" => Some(Self::AddRole),
                "RemoveRole" => Some(Self::RemoveRole),
                "UpdateMetadata" => Some(Self::UpdateMetadata),
                "StopNFTMint" => Some(Self::StopNftMint),
                "UpdateLogo" => Some(Self::UpdateLogo),
                "UpdateURIs" => Some(Self::UpdateUrIs),
                "ChangeRoyaltiesReceiver" => Some(Self::ChangeRoyaltiesReceiver),
                "UpdateStaking" => Some(Self::UpdateStaking),
                "UpdateRoyalties" => Some(Self::UpdateRoyalties),
                "UpdateKDAFeePool" => Some(Self::UpdateKdaFeePool),
                "StopRoyaltiesChange" => Some(Self::StopRoyaltiesChange),
                "StopNFTMetadataChange" => Some(Self::StopNftMetadataChange),
                _ => None,
            }
        }
    }
}
/// ValidatorConfig holds the data for a validator configuration
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorConfig {
    #[prost(bytes = "vec", tag = "1")]
    pub bls_public_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub reward_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "3")]
    pub can_delegate: bool,
    #[prost(uint32, tag = "4")]
    pub commission: u32,
    #[prost(int64, tag = "5")]
    pub max_delegation_amount: i64,
    #[prost(string, tag = "6")]
    pub logo: ::prost::alloc::string::String,
    #[prost(btree_map = "string, string", tag = "7")]
    pub ur_is: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "8")]
    pub name: ::prost::alloc::string::String,
}
/// CreateValidatorContract holds the data for create a validator
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateValidatorContract {
    #[prost(bytes = "vec", tag = "1")]
    pub owner_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<ValidatorConfig>,
}
/// ValidatorConfigContract holds the data for a validator configuration transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidatorConfigContract {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<ValidatorConfig>,
}
/// FreezeContract holds the data for a freeze transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FreezeContract {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub amount: i64,
}
/// UnfreezeContract holds the data for a unfreeze transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnfreezeContract {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub bucket_id: ::prost::alloc::vec::Vec<u8>,
}
/// DelegateContract holds the data for a delegate transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DelegateContract {
    #[prost(bytes = "vec", tag = "1")]
    pub to_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub bucket_id: ::prost::alloc::vec::Vec<u8>,
}
/// UndelegateContract holds the data for a undelegate transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndelegateContract {
    #[prost(bytes = "vec", tag = "1")]
    pub bucket_id: ::prost::alloc::vec::Vec<u8>,
}
/// WithdrawContract holds the data for a withdraw transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawContract {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "withdraw_contract::EnumWithdrawType", tag = "2")]
    pub withdraw_type: i32,
    #[prost(int64, tag = "3")]
    pub amount: i64,
    #[prost(bytes = "vec", tag = "4")]
    pub currency_id: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `WithdrawContract`.
pub mod withdraw_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumWithdrawType {
        Staking = 0,
        KdaPool = 1,
    }
    impl EnumWithdrawType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Staking => "Staking",
                Self::KdaPool => "KDAPool",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Staking" => Some(Self::Staking),
                "KDAPool" => Some(Self::KdaPool),
                _ => None,
            }
        }
    }
}
/// ClaimContract holds the data for a claim transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClaimContract {
    #[prost(enumeration = "claim_contract::EnumClaimType", tag = "1")]
    pub claim_type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `ClaimContract`.
pub mod claim_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumClaimType {
        StakingClaim = 0,
        AllowanceClaim = 1,
        MarketClaim = 2,
    }
    impl EnumClaimType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StakingClaim => "StakingClaim",
                Self::AllowanceClaim => "AllowanceClaim",
                Self::MarketClaim => "MarketClaim",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "StakingClaim" => Some(Self::StakingClaim),
                "AllowanceClaim" => Some(Self::AllowanceClaim),
                "MarketClaim" => Some(Self::MarketClaim),
                _ => None,
            }
        }
    }
}
/// UnjailContract holds the data for a unjail transaction
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnjailContract {}
/// SetAccountNameContract holds the data for a setAccountName transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAccountNameContract {
    #[prost(bytes = "vec", tag = "1")]
    pub name: ::prost::alloc::vec::Vec<u8>,
}
/// ProposalContract holds the data for a proposal transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalContract {
    #[prost(btree_map = "int32, bytes", tag = "1")]
    pub parameters: ::prost::alloc::collections::BTreeMap<
        i32,
        ::prost::alloc::vec::Vec<u8>,
    >,
    #[prost(bytes = "vec", tag = "2")]
    pub description: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub epochs_duration: u32,
}
/// VoteContract holds the data for a vote transaction
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VoteContract {
    #[prost(uint64, tag = "1")]
    pub proposal_id: u64,
    #[prost(int64, tag = "2")]
    pub amount: i64,
    #[prost(enumeration = "vote_contract::EnumVoteType", tag = "3")]
    pub r#type: i32,
}
/// Nested message and enum types in `VoteContract`.
pub mod vote_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumVoteType {
        Yes = 0,
        No = 1,
    }
    impl EnumVoteType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Yes => "Yes",
                Self::No => "No",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Yes" => Some(Self::Yes),
                "No" => Some(Self::No),
                _ => None,
            }
        }
    }
}
/// ConfigITOContract holds the data for a ConfigITO transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigItoContract {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub receiver_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "config_ito_contract::EnumItoStatus", tag = "3")]
    pub status: i32,
    #[prost(int64, tag = "4")]
    pub max_amount: i64,
    #[prost(btree_map = "string, message", tag = "5")]
    pub pack_info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        PackInfo,
    >,
    #[prost(int64, tag = "6")]
    pub default_limit_per_address: i64,
    #[prost(enumeration = "config_ito_contract::EnumItoStatus", tag = "7")]
    pub whitelist_status: i32,
    #[prost(btree_map = "string, message", tag = "8")]
    pub whitelist_info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        WhitelistInfo,
    >,
    #[prost(int64, tag = "9")]
    pub whitelist_start_time: i64,
    #[prost(int64, tag = "10")]
    pub whitelist_end_time: i64,
    #[prost(int64, tag = "11")]
    pub start_time: i64,
    #[prost(int64, tag = "12")]
    pub end_time: i64,
}
/// Nested message and enum types in `ConfigITOContract`.
pub mod config_ito_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumItoStatus {
        DefaultIto = 0,
        ActiveIto = 1,
        PausedIto = 2,
    }
    impl EnumItoStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DefaultIto => "DefaultITO",
                Self::ActiveIto => "ActiveITO",
                Self::PausedIto => "PausedITO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DefaultITO" => Some(Self::DefaultIto),
                "ActiveITO" => Some(Self::ActiveIto),
                "PausedITO" => Some(Self::PausedIto),
                _ => None,
            }
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WhitelistInfo {
    #[prost(int64, tag = "1")]
    pub limit: i64,
}
/// SetITOPrices holds the data for a ConfigITO transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetItoPricesContract {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(btree_map = "string, message", tag = "2")]
    pub pack_info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        PackInfo,
    >,
}
/// ITOTriggerContract triggers assets functions
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ItoTriggerContract {
    #[prost(enumeration = "ito_trigger_contract::EnumItoTriggerType", tag = "1")]
    pub trigger_type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub receiver_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "ito_trigger_contract::EnumItoStatus", tag = "4")]
    pub status: i32,
    #[prost(int64, tag = "5")]
    pub max_amount: i64,
    #[prost(btree_map = "string, message", tag = "6")]
    pub pack_info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        PackInfo,
    >,
    #[prost(int64, tag = "7")]
    pub default_limit_per_address: i64,
    #[prost(enumeration = "ito_trigger_contract::EnumItoStatus", tag = "8")]
    pub whitelist_status: i32,
    #[prost(btree_map = "string, message", tag = "9")]
    pub whitelist_info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        WhitelistInfo,
    >,
    #[prost(int64, tag = "10")]
    pub whitelist_start_time: i64,
    #[prost(int64, tag = "11")]
    pub whitelist_end_time: i64,
    #[prost(int64, tag = "12")]
    pub start_time: i64,
    #[prost(int64, tag = "13")]
    pub end_time: i64,
}
/// Nested message and enum types in `ITOTriggerContract`.
pub mod ito_trigger_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumItoTriggerType {
        SetItoPrices = 0,
        UpdateStatus = 1,
        UpdateReceiverAddress = 2,
        UpdateMaxAmount = 3,
        UpdateDefaultLimitPerAddress = 4,
        UpdateTimes = 5,
        UpdateWhitelistStatus = 6,
        AddToWhitelist = 7,
        RemoveFromWhitelist = 8,
        UpdateWhitelistTimes = 9,
    }
    impl EnumItoTriggerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SetItoPrices => "SetITOPrices",
                Self::UpdateStatus => "UpdateStatus",
                Self::UpdateReceiverAddress => "UpdateReceiverAddress",
                Self::UpdateMaxAmount => "UpdateMaxAmount",
                Self::UpdateDefaultLimitPerAddress => "UpdateDefaultLimitPerAddress",
                Self::UpdateTimes => "UpdateTimes",
                Self::UpdateWhitelistStatus => "UpdateWhitelistStatus",
                Self::AddToWhitelist => "AddToWhitelist",
                Self::RemoveFromWhitelist => "RemoveFromWhitelist",
                Self::UpdateWhitelistTimes => "UpdateWhitelistTimes",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SetITOPrices" => Some(Self::SetItoPrices),
                "UpdateStatus" => Some(Self::UpdateStatus),
                "UpdateReceiverAddress" => Some(Self::UpdateReceiverAddress),
                "UpdateMaxAmount" => Some(Self::UpdateMaxAmount),
                "UpdateDefaultLimitPerAddress" => {
                    Some(Self::UpdateDefaultLimitPerAddress)
                }
                "UpdateTimes" => Some(Self::UpdateTimes),
                "UpdateWhitelistStatus" => Some(Self::UpdateWhitelistStatus),
                "AddToWhitelist" => Some(Self::AddToWhitelist),
                "RemoveFromWhitelist" => Some(Self::RemoveFromWhitelist),
                "UpdateWhitelistTimes" => Some(Self::UpdateWhitelistTimes),
                _ => None,
            }
        }
    }
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumItoStatus {
        DefaultIto = 0,
        ActiveIto = 1,
        PausedIto = 2,
    }
    impl EnumItoStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DefaultIto => "DefaultITO",
                Self::ActiveIto => "ActiveITO",
                Self::PausedIto => "PausedITO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DefaultITO" => Some(Self::DefaultIto),
                "ActiveITO" => Some(Self::ActiveIto),
                "PausedITO" => Some(Self::PausedIto),
                _ => None,
            }
        }
    }
}
/// PackInfo holds the pack list structure for the ITO contract
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackInfo {
    #[prost(message, repeated, tag = "1")]
    pub packs: ::prost::alloc::vec::Vec<PackItem>,
}
/// PackItem hold the pack structure for the ITO contract
#[allow(dead_code)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PackItem {
    #[prost(int64, tag = "1")]
    pub amount: i64,
    #[prost(int64, tag = "2")]
    pub price: i64,
}
/// BuyContract holds the data for a buy transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuyContract {
    #[prost(enumeration = "buy_contract::EnumBuyType", tag = "1")]
    pub buy_type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub currency_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "4")]
    pub amount: i64,
}
/// Nested message and enum types in `BuyContract`.
pub mod buy_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumBuyType {
        ItoBuy = 0,
        MarketBuy = 1,
    }
    impl EnumBuyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ItoBuy => "ITOBuy",
                Self::MarketBuy => "MarketBuy",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ITOBuy" => Some(Self::ItoBuy),
                "MarketBuy" => Some(Self::MarketBuy),
                _ => None,
            }
        }
    }
}
/// SellContract holds the data for a sell transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SellContract {
    #[prost(enumeration = "sell_contract::EnumMarketType", tag = "1")]
    pub market_type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub marketplace_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub currency_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "5")]
    pub price: i64,
    #[prost(int64, tag = "6")]
    pub reserve_price: i64,
    #[prost(int64, tag = "7")]
    pub end_time: i64,
}
/// Nested message and enum types in `SellContract`.
pub mod sell_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumMarketType {
        BuyItNowMarket = 0,
        AuctionMarket = 1,
    }
    impl EnumMarketType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BuyItNowMarket => "BuyItNowMarket",
                Self::AuctionMarket => "AuctionMarket",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BuyItNowMarket" => Some(Self::BuyItNowMarket),
                "AuctionMarket" => Some(Self::AuctionMarket),
                _ => None,
            }
        }
    }
}
/// CancelMarketOrderContract holds the data for a cancel market transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelMarketOrderContract {
    #[prost(bytes = "vec", tag = "1")]
    pub order_id: ::prost::alloc::vec::Vec<u8>,
}
/// CreateMarketplaceContract holds the data for a create marketplace transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMarketplaceContract {
    #[prost(bytes = "vec", tag = "1")]
    pub name: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub referral_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub referral_percentage: u32,
}
/// ConfigMarketplaceContract holds the data for a config marketplace transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigMarketplaceContract {
    #[prost(bytes = "vec", tag = "1")]
    pub marketplace_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub name: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub referral_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "4")]
    pub referral_percentage: u32,
}
/// TODO: Reuse from account
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccKey {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub weight: i64,
}
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccPermission {
    #[prost(enumeration = "acc_permission::AccPermissionType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub permission_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub threshold: i64,
    /// 1 bit 1 contract
    #[prost(bytes = "vec", tag = "5")]
    pub operations: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "6")]
    pub signers: ::prost::alloc::vec::Vec<AccKey>,
}
/// Nested message and enum types in `AccPermission`.
pub mod acc_permission {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccPermissionType {
        Owner = 0,
        User = 1,
    }
    impl AccPermissionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Owner => "Owner",
                Self::User => "User",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Owner" => Some(Self::Owner),
                "User" => Some(Self::User),
                _ => None,
            }
        }
    }
}
/// UpdateAccountPermissionContract holds the data for update account permission transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccountPermissionContract {
    #[prost(message, repeated, tag = "8")]
    pub permissions: ::prost::alloc::vec::Vec<AccPermission>,
}
/// DepositContract holds the data for a deposit transaction
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DepositContract {
    #[prost(enumeration = "deposit_contract::EnumDepositType", tag = "1")]
    pub deposit_type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub currency_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "4")]
    pub amount: i64,
}
/// Nested message and enum types in `DepositContract`.
pub mod deposit_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumDepositType {
        FprDeposit = 0,
        KdaPool = 1,
    }
    impl EnumDepositType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::FprDeposit => "FPRDeposit",
                Self::KdaPool => "KDAPool",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FPRDeposit" => Some(Self::FprDeposit),
                "KDAPool" => Some(Self::KdaPool),
                _ => None,
            }
        }
    }
}
/// TXContract available
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxContract {
    #[prost(enumeration = "tx_contract::ContractType", tag = "1")]
    pub r#type: i32,
    #[prost(message, optional, tag = "2")]
    pub parameter: ::core::option::Option<crate::protos::Any>,
}
/// Nested message and enum types in `TXContract`.
pub mod tx_contract {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContractType {
        TransferContractType = 0,
        CreateAssetContractType = 1,
        CreateValidatorContractType = 2,
        ValidatorConfigContractType = 3,
        FreezeContractType = 4,
        UnfreezeContractType = 5,
        DelegateContractType = 6,
        UndelegateContractType = 7,
        WithdrawContractType = 8,
        ClaimContractType = 9,
        UnjailContractType = 10,
        AssetTriggerContractType = 11,
        SetAccountNameContractType = 12,
        ProposalContractType = 13,
        VoteContractType = 14,
        ConfigItoContractType = 15,
        SetItoPricesContractType = 16,
        BuyContractType = 17,
        SellContractType = 18,
        CancelMarketOrderContractType = 19,
        CreateMarketplaceContractType = 20,
        ConfigMarketplaceContractType = 21,
        UpdateAccountPermissionContractType = 22,
        DepositContractType = 23,
        ItoTriggerContractType = 24,
        SmartContractType = 63,
    }
    impl ContractType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TransferContractType => "TransferContractType",
                Self::CreateAssetContractType => "CreateAssetContractType",
                Self::CreateValidatorContractType => "CreateValidatorContractType",
                Self::ValidatorConfigContractType => "ValidatorConfigContractType",
                Self::FreezeContractType => "FreezeContractType",
                Self::UnfreezeContractType => "UnfreezeContractType",
                Self::DelegateContractType => "DelegateContractType",
                Self::UndelegateContractType => "UndelegateContractType",
                Self::WithdrawContractType => "WithdrawContractType",
                Self::ClaimContractType => "ClaimContractType",
                Self::UnjailContractType => "UnjailContractType",
                Self::AssetTriggerContractType => "AssetTriggerContractType",
                Self::SetAccountNameContractType => "SetAccountNameContractType",
                Self::ProposalContractType => "ProposalContractType",
                Self::VoteContractType => "VoteContractType",
                Self::ConfigItoContractType => "ConfigITOContractType",
                Self::SetItoPricesContractType => "SetITOPricesContractType",
                Self::BuyContractType => "BuyContractType",
                Self::SellContractType => "SellContractType",
                Self::CancelMarketOrderContractType => "CancelMarketOrderContractType",
                Self::CreateMarketplaceContractType => "CreateMarketplaceContractType",
                Self::ConfigMarketplaceContractType => "ConfigMarketplaceContractType",
                Self::UpdateAccountPermissionContractType => {
                    "UpdateAccountPermissionContractType"
                }
                Self::DepositContractType => "DepositContractType",
                Self::ItoTriggerContractType => "ITOTriggerContractType",
                Self::SmartContractType => "SmartContractType",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TransferContractType" => Some(Self::TransferContractType),
                "CreateAssetContractType" => Some(Self::CreateAssetContractType),
                "CreateValidatorContractType" => Some(Self::CreateValidatorContractType),
                "ValidatorConfigContractType" => Some(Self::ValidatorConfigContractType),
                "FreezeContractType" => Some(Self::FreezeContractType),
                "UnfreezeContractType" => Some(Self::UnfreezeContractType),
                "DelegateContractType" => Some(Self::DelegateContractType),
                "UndelegateContractType" => Some(Self::UndelegateContractType),
                "WithdrawContractType" => Some(Self::WithdrawContractType),
                "ClaimContractType" => Some(Self::ClaimContractType),
                "UnjailContractType" => Some(Self::UnjailContractType),
                "AssetTriggerContractType" => Some(Self::AssetTriggerContractType),
                "SetAccountNameContractType" => Some(Self::SetAccountNameContractType),
                "ProposalContractType" => Some(Self::ProposalContractType),
                "VoteContractType" => Some(Self::VoteContractType),
                "ConfigITOContractType" => Some(Self::ConfigItoContractType),
                "SetITOPricesContractType" => Some(Self::SetItoPricesContractType),
                "BuyContractType" => Some(Self::BuyContractType),
                "SellContractType" => Some(Self::SellContractType),
                "CancelMarketOrderContractType" => {
                    Some(Self::CancelMarketOrderContractType)
                }
                "CreateMarketplaceContractType" => {
                    Some(Self::CreateMarketplaceContractType)
                }
                "ConfigMarketplaceContractType" => {
                    Some(Self::ConfigMarketplaceContractType)
                }
                "UpdateAccountPermissionContractType" => {
                    Some(Self::UpdateAccountPermissionContractType)
                }
                "DepositContractType" => Some(Self::DepositContractType),
                "ITOTriggerContractType" => Some(Self::ItoTriggerContractType),
                "SmartContractType" => Some(Self::SmartContractType),
                _ => None,
            }
        }
    }
}
/// Transaction holds all the data needed for a value transfer
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(message, optional, tag = "1")]
    pub raw_data: ::core::option::Option<transaction::Raw>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(enumeration = "transaction::TxResult", tag = "3")]
    pub result: i32,
    #[prost(enumeration = "transaction::TxResultCode", tag = "4")]
    pub result_code: i32,
    #[prost(message, repeated, tag = "5")]
    pub receipts: ::prost::alloc::vec::Vec<transaction::Receipt>,
    #[prost(uint64, tag = "6")]
    pub block: u64,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    #[allow(dead_code)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KdaFee {
        #[prost(bytes = "vec", tag = "1")]
        pub kda: ::prost::alloc::vec::Vec<u8>,
        /// TODO: allow spread
        #[prost(int64, tag = "2")]
        pub amount: i64,
    }
    #[allow(dead_code)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Raw {
        #[prost(uint64, tag = "1")]
        pub nonce: u64,
        #[prost(bytes = "vec", tag = "2")]
        pub sender: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, repeated, tag = "6")]
        pub contract: ::prost::alloc::vec::Vec<super::TxContract>,
        #[prost(int32, tag = "7")]
        pub permission_id: i32,
        #[prost(bytes = "vec", repeated, tag = "10")]
        pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
        #[prost(int64, tag = "13")]
        pub k_app_fee: i64,
        #[prost(int64, tag = "14")]
        pub bandwidth_fee: i64,
        #[prost(uint32, tag = "15")]
        pub version: u32,
        #[prost(bytes = "vec", tag = "16")]
        pub chain_id: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "17")]
        pub kda_fee: ::core::option::Option<KdaFee>,
    }
    #[allow(dead_code)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Receipt {
        #[prost(bytes = "vec", repeated, tag = "1")]
        pub data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TxResult {
        Success = 0,
        Failed = 1,
    }
    impl TxResult {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Success => "SUCCESS",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUCCESS" => Some(Self::Success),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TxResultCode {
        Ok = 0,
        OutOfFunds = 1,
        AccountError = 2,
        AssetError = 3,
        ContractInvalid = 4,
        ContractNotFound = 5,
        FeeInvalid = 6,
        ParameterInvalid = 7,
        AprInvalid = 8,
        AssetIdInvalid = 9,
        AssetTypeInvalid = 10,
        AssetCantBeMinted = 11,
        AssetCantBeBurned = 12,
        AssetCantBePaused = 13,
        AssetCantBeDelegated = 14,
        AssetOwnerCantBeChanged = 15,
        AccountNotOwner = 16,
        CommissionTooHigh = 17,
        DelegationAmountInvalid = 18,
        ProposalNotActive = 19,
        ValueInvalid = 20,
        AmountInvalid = 21,
        BucketIdInvalid = 22,
        KeyConflict = 23,
        MaxDelegationAmount = 24,
        InvalidPeerKey = 25,
        MinKfiStakedUnreached = 26,
        MaxSupplyExeeced = 27,
        SaveAccountError = 28,
        LoadAccountError = 29,
        SameAccountError = 30,
        AssetPaused = 31,
        DeletegateError = 32,
        WithdrawNotAvailable = 33,
        ErrOverflow = 34,
        SetStakingErr = 35,
        SetMarketOrderErr = 36,
        BalanceError = 37,
        KappError = 38,
        UnfreezeError = 39,
        UndeletegateError = 40,
        WithdrawError = 41,
        ClaimError = 42,
        BucketsExceded = 43,
        AssetCantBeWiped = 44,
        AssetCantAddRoles = 45,
        FreezeError = 46,
        ItoNotActive = 47,
        NftMintStopped = 48,
        RoyaltiesChangeStopped = 49,
        ItokappError = 50,
        ItoWhiteListError = 51,
        NftMetadataChangeStopped = 52,
        AlreadyExists = 53,
        Fail = 99,
    }
    impl TxResultCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Ok => "Ok",
                Self::OutOfFunds => "OutOfFunds",
                Self::AccountError => "AccountError",
                Self::AssetError => "AssetError",
                Self::ContractInvalid => "ContractInvalid",
                Self::ContractNotFound => "ContractNotFound",
                Self::FeeInvalid => "FeeInvalid",
                Self::ParameterInvalid => "ParameterInvalid",
                Self::AprInvalid => "APRInvalid",
                Self::AssetIdInvalid => "AssetIDInvalid",
                Self::AssetTypeInvalid => "AssetTypeInvalid",
                Self::AssetCantBeMinted => "AssetCantBeMinted",
                Self::AssetCantBeBurned => "AssetCantBeBurned",
                Self::AssetCantBePaused => "AssetCantBePaused",
                Self::AssetCantBeDelegated => "AssetCantBeDelegated",
                Self::AssetOwnerCantBeChanged => "AssetOwnerCantBeChanged",
                Self::AccountNotOwner => "AccountNotOwner",
                Self::CommissionTooHigh => "CommissionTooHigh",
                Self::DelegationAmountInvalid => "DelegationAmountInvalid",
                Self::ProposalNotActive => "ProposalNotActive",
                Self::ValueInvalid => "ValueInvalid",
                Self::AmountInvalid => "AmountInvalid",
                Self::BucketIdInvalid => "BucketIDInvalid",
                Self::KeyConflict => "KeyConflict",
                Self::MaxDelegationAmount => "MaxDelegationAmount",
                Self::InvalidPeerKey => "InvalidPeerKey",
                Self::MinKfiStakedUnreached => "MinKFIStakedUnreached",
                Self::MaxSupplyExeeced => "MaxSupplyExeeced",
                Self::SaveAccountError => "SaveAccountError",
                Self::LoadAccountError => "LoadAccountError",
                Self::SameAccountError => "SameAccountError",
                Self::AssetPaused => "AssetPaused",
                Self::DeletegateError => "DeletegateError",
                Self::WithdrawNotAvailable => "WithdrawNotAvailable",
                Self::ErrOverflow => "ErrOverflow",
                Self::SetStakingErr => "SetStakingErr",
                Self::SetMarketOrderErr => "SetMarketOrderErr",
                Self::BalanceError => "BalanceError",
                Self::KappError => "KAPPError",
                Self::UnfreezeError => "UnfreezeError",
                Self::UndeletegateError => "UndeletegateError",
                Self::WithdrawError => "WithdrawError",
                Self::ClaimError => "ClaimError",
                Self::BucketsExceded => "BucketsExceded",
                Self::AssetCantBeWiped => "AssetCantBeWiped",
                Self::AssetCantAddRoles => "AssetCantAddRoles",
                Self::FreezeError => "FreezeError",
                Self::ItoNotActive => "ITONotActive",
                Self::NftMintStopped => "NFTMintStopped",
                Self::RoyaltiesChangeStopped => "RoyaltiesChangeStopped",
                Self::ItokappError => "ITOKAPPError",
                Self::ItoWhiteListError => "ITOWhiteListError",
                Self::NftMetadataChangeStopped => "NFTMetadataChangeStopped",
                Self::AlreadyExists => "AlreadyExists",
                Self::Fail => "Fail",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Ok" => Some(Self::Ok),
                "OutOfFunds" => Some(Self::OutOfFunds),
                "AccountError" => Some(Self::AccountError),
                "AssetError" => Some(Self::AssetError),
                "ContractInvalid" => Some(Self::ContractInvalid),
                "ContractNotFound" => Some(Self::ContractNotFound),
                "FeeInvalid" => Some(Self::FeeInvalid),
                "ParameterInvalid" => Some(Self::ParameterInvalid),
                "APRInvalid" => Some(Self::AprInvalid),
                "AssetIDInvalid" => Some(Self::AssetIdInvalid),
                "AssetTypeInvalid" => Some(Self::AssetTypeInvalid),
                "AssetCantBeMinted" => Some(Self::AssetCantBeMinted),
                "AssetCantBeBurned" => Some(Self::AssetCantBeBurned),
                "AssetCantBePaused" => Some(Self::AssetCantBePaused),
                "AssetCantBeDelegated" => Some(Self::AssetCantBeDelegated),
                "AssetOwnerCantBeChanged" => Some(Self::AssetOwnerCantBeChanged),
                "AccountNotOwner" => Some(Self::AccountNotOwner),
                "CommissionTooHigh" => Some(Self::CommissionTooHigh),
                "DelegationAmountInvalid" => Some(Self::DelegationAmountInvalid),
                "ProposalNotActive" => Some(Self::ProposalNotActive),
                "ValueInvalid" => Some(Self::ValueInvalid),
                "AmountInvalid" => Some(Self::AmountInvalid),
                "BucketIDInvalid" => Some(Self::BucketIdInvalid),
                "KeyConflict" => Some(Self::KeyConflict),
                "MaxDelegationAmount" => Some(Self::MaxDelegationAmount),
                "InvalidPeerKey" => Some(Self::InvalidPeerKey),
                "MinKFIStakedUnreached" => Some(Self::MinKfiStakedUnreached),
                "MaxSupplyExeeced" => Some(Self::MaxSupplyExeeced),
                "SaveAccountError" => Some(Self::SaveAccountError),
                "LoadAccountError" => Some(Self::LoadAccountError),
                "SameAccountError" => Some(Self::SameAccountError),
                "AssetPaused" => Some(Self::AssetPaused),
                "DeletegateError" => Some(Self::DeletegateError),
                "WithdrawNotAvailable" => Some(Self::WithdrawNotAvailable),
                "ErrOverflow" => Some(Self::ErrOverflow),
                "SetStakingErr" => Some(Self::SetStakingErr),
                "SetMarketOrderErr" => Some(Self::SetMarketOrderErr),
                "BalanceError" => Some(Self::BalanceError),
                "KAPPError" => Some(Self::KappError),
                "UnfreezeError" => Some(Self::UnfreezeError),
                "UndeletegateError" => Some(Self::UndeletegateError),
                "WithdrawError" => Some(Self::WithdrawError),
                "ClaimError" => Some(Self::ClaimError),
                "BucketsExceded" => Some(Self::BucketsExceded),
                "AssetCantBeWiped" => Some(Self::AssetCantBeWiped),
                "AssetCantAddRoles" => Some(Self::AssetCantAddRoles),
                "FreezeError" => Some(Self::FreezeError),
                "ITONotActive" => Some(Self::ItoNotActive),
                "NFTMintStopped" => Some(Self::NftMintStopped),
                "RoyaltiesChangeStopped" => Some(Self::RoyaltiesChangeStopped),
                "ITOKAPPError" => Some(Self::ItokappError),
                "ITOWhiteListError" => Some(Self::ItoWhiteListError),
                "NFTMetadataChangeStopped" => Some(Self::NftMetadataChangeStopped),
                "AlreadyExists" => Some(Self::AlreadyExists),
                "Fail" => Some(Self::Fail),
                _ => None,
            }
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Key {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub weight: i64,
}
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permission {
    #[prost(int32, tag = "1")]
    pub id: i32,
    #[prost(enumeration = "permission::PermissionType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub permission_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub threshold: i64,
    #[prost(bytes = "vec", tag = "5")]
    pub operations: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "6")]
    pub signers: ::prost::alloc::vec::Vec<Key>,
}
/// Nested message and enum types in `Permission`.
pub mod permission {
    #[allow(dead_code)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PermissionType {
        Owner = 0,
        User = 1,
    }
    impl PermissionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Owner => "Owner",
                Self::User => "User",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Owner" => Some(Self::Owner),
                "User" => Some(Self::User),
                _ => None,
            }
        }
    }
}
#[allow(dead_code)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserAccountData {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub name: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub root_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "5")]
    pub balance: i64,
    #[prost(int64, tag = "6")]
    pub allowance: i64,
    #[prost(uint64, tag = "7")]
    pub nonce: u64,
    #[prost(message, repeated, tag = "8")]
    pub permissions: ::prost::alloc::vec::Vec<Permission>,
}
